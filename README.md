# Mikan Script
めっちゃ単純だけど本格的なスクリプト言語を作りたい！
というわけで作っているもの

## アイデンティティ
1. インタプリタの美しさ わかりやすさ
2. 柔軟性
3. 速度
4. 安全性
5. 書き心地

1を達成すれば2も3も4も5も達成される  
という風に相互関係があると思う

# todo
- [x] VMの軽い実装
- [x] パフォーマンスチューニング
- [ ] データ型の一般化？
- [ ] 非同期系の対応
- [ ] マルチスレッド系の対応
- [ ] 言語仕様とロジックの設計
- [ ] 軽くパーサー実装
- [ ] パフォーマンスチューニング
- [ ] パーサーと解析系のフル実装
- [ ] 標準lib書きまくる
- [ ] JIT実装
  
# 現時点でのパフォーマンス

1. カウントループ(ディスパッチが支配的な最悪ベンチ)
    ```rust
    let b = 1000_000_000u64;
    let mut a = 0u64;
    while a < b {
        a += 1;
    }
    println!("{}", a);
    ```
    結果
    - ネイティブ 500ms
    - VM 2745ms

    => 相対 0.182× (5.5× 遅延)

2. メモリアクセスAtomicカウントループ(ディスパッチと仮想メモリアクセス最適化具合)
    ```rust
    const LIMIT: u64 = 1_000_000_000;
    let counter = AtomicU64::new(0);

    loop {
        counter.fetch_add(1, Ordering::Relaxed);
        let val = counter.load(Ordering::Relaxed);
        if val >= LIMIT {
            break;
        }
    }
    ```
    結果
    - ネイティブ 7400ms
    - VM 8900ms

    => 相対 0.831× (1.20× 遅延)

# プリミティブの扱いに関して
演算や比較は基本的にu64のみ  
load store で u64~u8 に対応

数値の扱いとして  
i8でのloadはi64で符号bitだけ64bit目に移動処理が入ります  
i8のstoreではi64の下位7bitと上位1bitを合成したものが入ります。  

ADCは実装されていませんがu32で演算を行いu64として比較することでCF又はOFの代わりになります。  

atomic操作などに対応します

# バイトコードの読み込み
遅延ロードに対応します  

未ロードの関数を `Operations::get_decode` に置き換えます  
呼び出された場合CodeManagerにデコードを依頼し、VMのFuctionTableを更新します  
これにより遅延ロードを実現します  


